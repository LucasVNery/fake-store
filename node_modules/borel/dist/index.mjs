import { Num, NumLoose } from 'typen';

// import { quickSort, quickSortBy } from './sort/quickSort'
// import { timSort } from './sort/timSort'
// If compareFunction(a, b) is less than 0, sort a to an index lower than b (i.e. a comes first).
// If compareFunction(a, b) returns 0, leave a and b unchanged with respect to each other.
// If compareFunction(a, b) is greater than 0, sort b to an index lower than a (i.e. b comes first).
class Comparer {
  static stringAscending(a, b) {
    return a.localeCompare(b);
  }

  static stringDescending(a, b) {
    return b.localeCompare(a);
  }

  static numberAscending(a, b) {
    return a - b;
  }

  static numberDescending(a, b) {
    return b - a;
  }

}

class Rank {
  /**
   *
   * @param {*[]} arr
   * @param {function(*,*):number} comparer Compare 'prev' & 'next' element in an array. If return negative number or
   * zero, then 'prev' comes first, else 'next' comes first.
   * @return {*[]} Sorted arr.
   */
  static sort(arr, comparer) {
    return arr.slice().sort(comparer);
  }
  /**
   *
   * @param {*[]} arr
   * @param {function(*,*):number} comparer Compare 'prev' & 'next' element in an array. If return < 0, 'prev' comes first. If return > 0, 'next' comes first.
   * @param {function(*):boolean} [filter]
   * @return {number[]} Rank order array, where 0 denote the first.
   */


  static rank(arr, comparer, filter) {
    const sorted = (!filter ? arr.slice() : arr.filter(filter)).sort(comparer);
    return arr.map(x => sorted.indexOf(x));
  }
  /**
   *
   * @param {*[]} arr
   * @param {number[]} arrRank array of the same length as 'arr', containing rank order of 'arr', 0 comes first.
   * @return {*[]}
   */


  static reorderBy(arr, arrRank) {
    const rsl = Array(arr.length);

    for (let [i, ord] of arrRank.entries()) rsl[ord] = arr[i];

    return rsl;
  }

}

const IsNum = (level = 0) => {
  switch (level) {
    case 0:
      return x => !isNaN(x);

    case 1:
      return NumLoose.isNumeric;

    case 2:
    default:
      return Num.isNumeric;
  }
};

const firstNumInArray = (ar, lo, hi, {
  level = 0
} = {}) => {
  for (let el, isNum = IsNum(level); lo < hi; lo++) if (isNum(el = ar[lo])) return [lo, el];

  return [hi, NaN];
};
const firstNumInMatrix = (mx, t, b, l, r, {
  level = 0
} = {}) => {
  for (let el, isNum = IsNum(level); t < b; t++) for (l = 0; l < r; l++) if (isNum(el = mx[t][l])) return [t, l, el];

  return [b, r, NaN];
};
const firstNumInColumn = (mx, t, b, c, {
  level = 0
} = {}) => {
  for (let el, isNum = IsNum(level); t < b; t++) if (isNum(el = mx[t][c])) return [t, el];

  return [b, NaN];
};

function bound(max, min) {
  return this.dif ? {
    min,
    dif: max - min
  } : {
    max,
    min
  };
}
const Bound = dif => bound.bind({
  dif
});

const ToNum = (level = 0) => {
  switch (level) {
    case 0:
      return x => x;

    case 1:
      return NumLoose.numeric;

    case 2:
    default:
      return Num.numeric;
  }
};

function sortEntries(entries, sort) {
  switch (sort) {
    case true:
    case 'desc':
      return entries.sort(([, a], [, b]) => b - a);

    case 'asc':
      return entries.sort(([, a], [, b]) => a - b);

    case false:
    default:
      return entries;
  }
}

const plusOrZero = x => x ? x + 1 : 1;

class Stat {
  static cnt(arr) {
    return !!arr ? arr.length : 0;
  }
  /**
   *
   * @param {number[]} arr
   * @param {number} [level] - 0: no check, 1: loose check, 2: strict check
   * @returns {number}
   */


  static sum(arr, {
    level = 0
  } = {}) {
    if (!arr) return 0;
    const toNum = ToNum(level);
    let {
      length: l
    } = arr;

    switch (l) {
      case 0:
        return NaN;

      case 1:
        return level ? toNum(arr[0]) : arr[0];

      default:
        let sum = 0;

        if (level) {
          for (--l; l >= 0; l--) sum += toNum(arr[l]);
        } else {
          for (--l; l >= 0; l--) sum += arr[l];
        }

        return sum;
    }
  }
  /**
   *
   * @param {number[]} arr
   * @param {number} [level] - 0: no check, 1: loose check, 2: strict check
   * @returns {number}
   */


  static avg(arr, {
    level = 0
  } = {}) {
    return arr && arr.length ? Stat.sum(arr, {
      level
    }) / arr.length : 0;
  }

  static mode(arr) {
    return undefined;
  }
  /**
   *
   * @param {*[]} arr
   * @param {boolean} [count=false]
   * @param {string|boolean} [sort=false]
   * @returns {[any, any][]|[]|any[]|*}
   */


  static distinct(arr, {
    count = false,
    sort = false
  } = {}) {
    if (!arr) return count ? [[]] : [];
    const l = arr.length;
    if (!l) return count ? [[]] : [];

    if (count) {
      let ents;

      if (l <= 0x100) {
        ents = [];

        for (let i = 0, j, el; i < l; i++) {
          el = arr[i];
          j = ents.findIndex(x => el === x[0]);
          if (j < 0) j += ents.push([el, 0]);
          ents[j][1]++;
        }
      } else {
        const lx = new Map();

        for (let i = 0, el; i < l; i++) {
          el = arr[i];
          lx.set(el, plusOrZero(lx.get(el)));
        }

        ents = Array.from(lx.entries());
      }

      return sortEntries(ents, sort);
    } else {
      if (l <= 0x100) {
        const dist = [];

        for (let i = 0; i < l; i++) if (dist.indexOf(arr[i]) < 0) dist.push(arr[i]);

        return dist;
      } else {
        return Array.from(new Set(arr));
      }
    }
  }

  static median(arr) {
    return undefined;
  }
  /**
   *
   * @param {*[]} arr
   * @param {boolean} [dif=false]
   * @param {number} [level=0]
   * @returns {{min: *, max: *}|{min: *, dif: *}}}
   */


  static bound(arr, {
    dif = false,
    level = 0
  } = {}) {
    let l = arr && arr.length;
    const bound = Bound(dif);
    if (!l) return bound(NaN, NaN);
    const toNum = ToNum(level);
    let [i, x] = firstNumInArray(arr, 0, l, {
      level
    });
    let min,
        max = min = toNum(x);

    for (--l; l > i; l--) {
      x = toNum(arr[l]);

      if (x < min) {
        min = x;
      } else if (x > max) {
        max = x;
      }
    }

    return bound(max, min);
  } // Population standard deviation


  static stDevP(arr, {
    level = 0
  } = {}) {
    const cnt = Stat.cnt(arr);
    if (!cnt) return 0;
    const avg = Stat.avg(arr, {
      level
    });
    return Math.hypot(...arr.map(x => x - avg)) / Math.sqrt(cnt);
  } // Sample standard deviation


  static stDevS(arr, {
    level = 0
  } = {}) {
    const cnt = Stat.cnt(arr) - 1;
    if (!cnt) return 0;
    const avg = Stat.avg(arr, {
      level
    });
    return Math.hypot(...arr.map(x => x - avg)) / Math.sqrt(cnt);
  }
  /**
   *
   * @param {*[]} arr
   * @param {function(*):number} ject
   * @return {number}
   */


  static sumBy(arr, ject) {
    if (!arr) return NaN;
    const l = arr.length;

    switch (l) {
      case 0:
        return NaN;

      case 1:
        return ject(arr[0]);

      default:
        let sum = 0;

        for (let i = 0; i < l; i++) sum += ject(arr[i]);

        return sum;
    }
  }
  /**
   *
   * @param {*[]} arr
   * @param {function(*):number} ject
   * @return {number}
   */


  static maxBy(arr, ject) {
    if (!arr) return NaN;
    const l = arr.length;

    switch (l) {
      case 0:
        return NaN;

      case 1:
        return ject(arr[0]);

      default:
        let v,
            max = ject(arr[0]);

        for (let i = 1; i < l; i++) {
          v = ject(arr[i]);
          if (v > max) max = v;
        }

        return max;
    }
  }

}
//   let rsl = 0;
//   for (let i = 0; i < arr.length; i++) {
//     rsl += arr[i];
//   }
//   return rsl;
// }
// function sum (arr) {
//   switch (arr.length) {
//     case 0:
//       return NaN
//     case 1:
//       return arr[0]
//     default:
//       let sum = 0
//       for (let n of arr) {
//         sum += n
//       }
//       return sum
//   }
// }

const size = mx => {
  var _mx$;

  const l = mx === null || mx === void 0 ? void 0 : mx.length;
  return [l, l ? (_mx$ = mx[0]) === null || _mx$ === void 0 ? void 0 : _mx$.length : undefined];
};

class StatMx {
  static cnt(mx) {
    if (mx && mx.length) {
      const [row] = mx;
      if (row && row.length) return length * row.length;
    }

    return 0;
  }
  /**
   *
   * @param {*[]} mx
   * @param {boolean} [dif=false]
   * @param {number} [level=0]
   * @returns {{min: *, max: *}|{min: *, dif: *}}}
   */


  static bound(mx, {
    dif = false,
    level = 0
  } = {}) {
    let [h, w] = size(mx);
    if (!h || !w) return bound(NaN, NaN);
    const t = ToNum(level);
    let [i,, el] = firstNumInMatrix(mx, 0, h, 0, w, {
      level
    }),
        max = t(el),
        min = max,
        rowMax,
        rowMin;

    for (--h; h >= i; h--) {
      ({
        max: rowMax,
        min: rowMin
      } = Stat.bound(mx[h], {
        level
      }));

      if (rowMin < min) {
        min = rowMin;
      } else if (rowMax > max) {
        max = rowMax;
      }
    }

    return bound(max, min);
  }
  /**
   *
   * @param {*[]} mx
   * @param {number} y
   * @param {boolean} [dif=false]
   * @param {number} [level=0] - level: 0, none; 1, loose; 2, strict
   * @returns {{min: *, max: *}|{min: *, dif: *}}}
   */


  static boundCol(mx, y, {
    dif = false,
    level = 0
  } = {}) {
    let [h, w] = size(mx);
    if (!h || !w || y >= w) return bound(NaN, NaN);
    const t = ToNum(level);
    let [i, el] = firstNumInColumn(mx, 0, h, y, {
      level
    }),
        max = t(el),
        min = max;

    for (--h; h >= i; h--) {
      el = t(mx[h][y]);

      if (el < min) {
        min = el;
      } else if (el > max) {
        max = el;
      }
    }

    return bound(max, min);
  }

  static distinct(mx, y) {
    let [h, w] = size(mx);
    if (!h || !w || y >= w) return [[]];
    let rows = [];

    for (let i = 0, _r; i < h; i++) {
      _r = mx[i];
      if (rows.findIndex(r => _r[y] === r[y]) < 0) rows.push(_r);
    }

    return rows;
  }
  /**
   *
   * @param {*[]} mx
   * @param {number} y
   * @param {boolean} [count=false]
   * @param {string|boolean} [sort=false] - When sort is function, sort must be a comparer between two point element.
   * @returns {[any, any][]|[]|any[]|*}
   */


  static distinctCol(mx, y, {
    count = false,
    sort = false
  } = {}) {
    const [h, w] = size(mx);
    if (!h || !w || y >= w) return count ? [[]] : [];

    if (!count) {
      const dist = [];

      for (let i = 0, el; i < h; i++) {
        el = mx[i][y];
        if (dist.indexOf(el) < 0) dist.push(el);
      }

      return dist;
    } else {
      let ents = [];

      for (let i = 0, j, el; i < h; i++) {
        el = mx[i][y];
        j = ents.findIndex(x => el === x[0]);
        if (j < 0) j += ents.push([el, 0]);
        ents[j][1]++;
      }

      return sortEntries(ents, sort);
    }
  }

}

class Zu {
  /**
   * Generate a random integer between [min, max].
   * Both min & max are inclusive.
   * @param {Number} min  Int
   * @param {Number} max  Int
   * @returns {Number}  Int
   * @deprecated Prefer Roulett.between in npm package Roulett
   */
  static randBetween(min, max) {
    return ~~(Math.random() * (max - min + 1)) + min;
  }
  /**
   * Generate a random integer between [min, max).
   * Notice: min is inclusive & max is exclusive.
   * @param {Number} min  Int
   * @param {Number} max(exclusive)  Int
   * @returns {Number}  Int
   * @deprecated Prefer Roulett.rand in npm package Roulett
   */


  static rand(min, max) {
    return ~~(Math.random() * (max - min)) + min;
  }

  static almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }

  static almostInt(x, epsilon) {
    // let rounded = Math.round(x)
    // return rounded - epsilon < x && rounded + epsilon > x
    return Math.abs(x - Math.round(x)) < epsilon;
  }
  /**
   *
   * @param {number} x
   * @returns {number}
   */


  static intExponent(x) {
    return ~~Math.log10(x);
  }
  /**
   *
   * @param {number} x
   * @returns {number}
   */


  static round(x) {
    return x + (x > 0 ? 0.5 : -0.5) << 0;
  }

}
//   ? x => Math.log10(x)
//   : x => {
//     let exponent = Math.log(x) * Math.LOG10E // Math.LOG10E = 1 / Math.LN10.
//     // Check for whole powers of 10,
//     // which due to floating point rounding error should be corrected.
//     let powerOf10 = Math.round(exponent)
//     let isPowerOf10 = x === Math.pow(10, powerOf10)
//     return isPowerOf10 ? powerOf10 : exponent
//   }
// /**
//  * Generate a random integer between [min, max].
//  * Both min & max are inclusive.
//  * @param {Number} min  Int
//  * @param {Number} max  Int
//  * @returns {Number}  Int
//  */
// function between (min, max) {
//   return Math.floor(Math.random() * (max - min + 1)) + min
// }

export { Comparer, Rank, Stat, StatMx, Zu };
