// let protoType = function (it) {
//   const raw = typeof it;
//   if (raw === "object") {
//     switch (true) {
//       case (it instanceof Array):
//         return "array";
//       case (it instanceof Map):
//         return "map";
//       case (it instanceof Set):
//         return "set";
//       case (it instanceof Function):
//         return "function";
//       default:
//         return raw;
//     }
//   } else {
//     return raw
//   }
// };
const oc = Object.prototype.toString;
/**
 * const rxObj = /^\[object (.*)]$/
 * Equivalent to: Object.prototype.stringify.call(o).match(rxObj)[1]
 * @param {*} o
 * @return {string}
 */

const otype = o => oc.call(o).slice(8, -1);

class Typ {
  static protoType(o) {
    return oc.call(o);
  }

  static initial(o) {
    return oc.call(o).slice(8, 11);
  }

  static infer(o) {
    const t = typeof o;
    return t !== 'object' ? t : otype(o).toLowerCase();
  }

}

/**
 * validate
 * @param x
 * @param y
 * @returns {number}
 */

const vdt = (x, y) => isNaN(x - y) ? NaN : y;

class Num {
  // Angular 4.3
  static isNumeric(x) {
    return !isNaN(x - parseFloat(x));
  }

  static numeric(x) {
    return vdt(x, parseFloat(x));
  }

  static inferData(x) {
    const t = typeof x;
    return t === 'string' ? isNaN(x - parseFloat(x)) ? 'string' : 'numstr' : t === 'object' ? otype(x).toLowerCase() : t;
  }

}

const check = x => !!x || x === 0;

class NumLoose {
  static isNumeric(x) {
    return check(+x);
  }

  static numeric(x) {
    x = +x;
    return check(x) ? x : NaN;
  }
  /**
   *
   * @param {*} x
   * @return {string}
   */


  static inferData(x) {
    const t = typeof x;
    return t === 'string' ? check(+x) ? 'numstr' : 'string' : t === 'object' ? otype(x).toLowerCase() : t;
  }

}

/**
 *
 * @param x
 * @return {{
 * typeOf: ("undefined"|"object"|"boolean"|"number"|"string"|"function"|"symbol"|"bigint"),
 * protoType: *,
 * stringify: string
 * }}
 */

let check$1 = x => ({
  typeOf: typeof x,
  protoType: oc.call(x),
  stringify: `${x}`
});

export { Num, NumLoose, Typ, check$1 as check };
